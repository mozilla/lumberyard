{
  "name": "habitat",
  "version": "1.1.0",
  "description": "Small library for managing environment variables",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "xtend": "~2.1.1",
    "lodash.foreach": "~2.3.0",
    "lodash.reduce": "~2.3.0"
  },
  "devDependencies": {
    "tap": "~0.3.1"
  },
  "scripts": {
    "test": "tap test/*.test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/brianloveswords/habitat.git"
  },
  "keywords": [
    "environment",
    "variables",
    "management"
  ],
  "author": {
    "name": "Brian J. Brennan",
    "email": "@brianloveswords"
  },
  "license": "MIT",
  "readme": "# habitat [![Build Status](https://secure.travis-ci.org/brianloveswords/habitat.png)](http://travis-ci.org/brianloveswords/habitat)\n## Version 1.1.0\n\nLibrary for managing your environment vars.\n\n# Why\n\nAccording to [factor 3](http://www.12factor.net/config), you should be\nstoring your configuration as environment variables. Writing\n`process.env` everywhere can be real annoying, so this abstracts away of\nthat manipulation. It also provides some nice little nicities for testing.\n\n# Installation\n\nWhy NPM of course!\n\n```bash\n$ npm install habitat\n```\n\n# Usage\n\n## new habitat([*prefix*, [*defaults*]])\n\nCreates a new environment manipulator.\n\n`prefix` is the prefix for your environment variables. For example, if\nyour app is called `airsupport`, it's probably good to namespace your\nenvironment variables like so:\n\n```bash\nexport AIRSUPPORT_HOST='lolcathost'\nexport AIRSUPPORT_PORT=3000\nexport AIRSUPPORT_WEBSOCKETS=true\n```\n\nIn this case, you would use  `new habitat('airsupport')` -- the prefix will be\nauto-capitalized because only barbarians use lowercase letters in their\nenvironment variables.\n\n`defaults` is an object representing the defaults if a key cannot be\nfound in the environment. This should be used sparingly.\n\n```js\nvar env = new habitat('airsupport', { port: 1024 })\n// will try the environment first, then fall back to 1024\nvar port = env.get('port');\n```\n\n## habitat#get(key, [*default*])\n\nGets a key from the environment. Automatically prefixes with the\n`prefix` passed to the constructor, if necessary.\n\n`habitat#get` will also try to do some parsing of the value if it looks\nlike a `boolean`, `number` or `json`, so you can do things like this:\n\n```bash\nexport APP_ADMINS='[\"me@example.com\", \"you@example.com\"]'\n```\n```js\nvar env = new habitat('app');\nvar admins = env.get('admins');\nconsole.log(admins.indexOf('you@example.com')) // 1\n```\n\nIf a `default` is passed, if the key is undefined in either the env or\nthe constructor-set defaults, it will fall back to that.\n\n### Getting objects\n`get` will automatically return objects if you take advantage of common prefixing:\n\n```bash\nexport APP_DB='redis'\nexport APP_REDIS_HOST='127.0.0.1'\nexport APP_REDIS_PORT=6379\n```\n\n```js\nvar env = new habitat('app');\nvar db = env.get('db');\nvar options = env.get(db);\nconsole.log(options.host); // '127.0.0.1'\nconsole.log(options.port); // 6379\n```\n\n### Getting keys using camelCase\nYou can also use camelcase instead of underscores if you want, habitat's\ngot your back.\n\n```bash\nexport APP_SOME_LONG_KEY='great'\n```\n\n```js\nvar env = new habitat('app');\nconsole.log(env.get('someLongKey')) // 'great'\n```\n\n## habitat.get(key)\n\nYou can also use `get` directly from the habitat object to get\nunprefixed things from the environment.\n\n```js\nvar path = habitat.get('path');\nvar nodeEnv = habitat.get('nodeEnv');\n```\n\n## habitat.load([*pathToEnvFile*])\nTry to load a set of environment variables from a file. This **will** override whatever is in the environment.\n\nEnvironment file can be in the form of exports:\n\n```bash\n# /some/directory/.env\n# The leading `export` is optional.\n# Useful if you want to be able to also `source /some/directory/.env`\n\nexport PARAMETER_ONE=one\nexport PARAMETER_TWO=two\n```\n\nIt can also take JSON if you're into that:\n\n```json\n{\"parameterOne\": \"one\",\n \"parameterTwo\": \"two\"}\n```\n\n```js\nvar env = habitat.load('/some/directory/.env'); // returns true on success\nconsole.dir(env.get('parameter')); // { one: 'one', two: 'two' }\n```\n\n`pathToEnvFile` defaults to `'.env'`, which will just look for a .env\nfile in the current working directory.\n\n## habitat#set(key, value)\n\nSets an environment variable, with prefix if passed.\n\n## habitat#unset(key)\n\nUnsets an environment variable\n\n## habitat#all()\n\nGet an object with all of the things in the environment.\n\nExample:\n\n```bash\nexport APP_HOST='localhost'\nexport APP_PORT=3000\nexport APP_PROTO=http\n```\n```js\nvar env = new habitat('app');\nvar obj = env.all();\n\nconsole.log(obj.host); // 'localhost'\n```\n\n## habitat#temp(object, callback)\n\nTemporarily overrides environment variables with values from `object`.\n\n`callback` can be syncronous if defined without any parameters, or async\nif defined with a single parameter.\n\nExample:\n```js\n\nvar env = new habitat('airsupport', {\n  protocol: 'http',\n  host: 'airsupport.io',\n  port: 3000\n});\n\nvar tempEnv = {\n  host: 'lolcathost'\n  port: 5000\n};\n\n// sync\nenv.temp(tempEnv, function() {\n  console.log(env.get('host')) // \"lolcathost\"\n  console.log(process.env['AIRSUPPORT_HOST']) // \"lolcathost\"\n})\n\nconsole.log(env.get('host')) // \"airsupport.io\"\n\n// async\nenv.temp(tempEnv, function(done)\n  process.nextTick(function(){\n    console.log(env.get('port')) // 5000\n    done();\n  });\n})\n```\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/brianloveswords/habitat/issues"
  },
  "homepage": "https://github.com/brianloveswords/habitat",
  "_id": "habitat@1.1.0",
  "_from": "habitat@"
}
